<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Quick Stickies</title>
    <style>
        :root {
            --bg-color: #202020;
            --header-height: 32px;
            --footer-height: 48px;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 20px 20px;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            height: 100vh;
            width: 100vw;
        }

        #app-toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            z-index: 9999;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .btn-main {
            background: #0078D4;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            touch-action: manipulation;
            /* Enable clicks */
        }

        #board {
            position: relative;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }

        .note {
            position: absolute;
            display: flex;
            flex-direction: column;
            border-radius: 6px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            overflow: hidden;
            min-width: 200px;
            min-height: 200px;
        }

        .note.active {
            z-index: 1000;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6);
        }

        .note-header {
            height: 32px;
            background: rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            padding: 0 8px;
            cursor: grab;
        }

        .note-body {
            position: relative;
            flex-grow: 1;
            background: rgba(255, 255, 255, 0.1);
        }

        .note-textarea {
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            background: transparent;
            resize: none;
            padding: 10px;
            font-size: 18px;
            box-sizing: border-box;
        }

        .note-canvas {
            cursor: crosshair;
            touch-action: none;
        }

        .note-footer {
            height: 48px;
            background: rgba(0, 0, 0, 0.05);
            display: flex;
            align-items: center;
            justify-content: space-around;
        }

        .tool-btn {
            background: none;
            border: none;
            padding: 10px;
            cursor: pointer;
            font-weight: bold;
            opacity: 0.6;
            border-radius: 4px;
            touch-action: manipulation;
        }

        .tool-btn.active {
            background: rgba(0, 0, 0, 0.15);
            opacity: 1;
            color: #0078D4;
        }

        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
            touch-action: manipulation;
        }

        .color-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }

        .color-yellow {
            background-color: #fff7d1;
        }

        .color-green {
            background-color: #e4ffc1;
        }

        .color-pink {
            background-color: #ffdae9;
        }

        .color-blue {
            background-color: #e2f1ff;
        }

        .color-charcoal {
            background-color: #333333;
            color: white;
        }

        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 30px;
            height: 30px;
            cursor: nwse-resize;
            z-index: 100;
            background: linear-gradient(135deg, transparent 70%, rgba(0, 0, 0, 0.1) 70%);
        }

        #debug-console {
            position: fixed;
            bottom: 10px;
            left: 10px;
            width: 250px;
            height: 150px;
            background: rgba(0, 0, 0, 0.7);
            color: #0f0;
            font-family: monospace;
            font-size: 10px;
            pointer-events: none;
            padding: 5px;
            overflow: hidden;
            z-index: 10000;
            display: none;
        }

        /* ... existing CSS ... */
        .ink-popup {
            position: absolute;
            top: 40px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 2000;
            width: 160px;
        }

        .ink-row {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .ink-dot {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid rgba(0, 0, 0, 0.1);
        }

        .ink-dot.active {
            border-color: #0078D4;
            transform: scale(1.1);
        }
    </style>
</head>

<body>

    <div id="app-toolbar">
        <div style="color:white; font-weight:bold; font-size:18px;">Stickies</div>
        <div style="display:flex; gap:8px;">
            <button class="btn-main" style="background:#444;" onclick="app.toggleFullscreen()">FULLSCREEN</button>
            <button class="btn-main" style="background:#444;" onclick="app.toggleDebug()">DEBUG</button>
            <button class="btn-main" onclick="app.addNote()">+ NEW NOTE</button>
        </div>
    </div>

    <div id="debug-console"></div>
    <div id="board"></div>

    <script>
        class App {
            /* ... existing App methods ... */
            constructor() {
                try {
                    this.notes = [];
                    this.container = document.getElementById('board');
                    this.colors = ['yellow', 'green', 'pink', 'blue', 'charcoal'];
                    this.inkColors = ['#222222', '#1976D2', '#D32F2F', '#388E3C', '#FFFFFF'];

                    this.load();
                    setInterval(() => this.save(), 5000);
                } catch (e) {
                    alert("App Init Error: " + e.message);
                }
            }
            /* ... rest of App ... */
            log(msg) {
                const dbg = document.getElementById('debug-console');
                if (!dbg) return;
                const line = document.createElement('div');
                line.textContent = `> ${msg}`;
                dbg.prepend(line);
                if (dbg.children.length > 15) dbg.lastChild.remove();
            }

            toggleDebug() {
                const dbg = document.getElementById('debug-console');
                dbg.style.display = dbg.style.display === 'none' ? 'block' : 'none';
            }

            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(e => this.log("FS Er: " + e.message));
                } else {
                    document.exitFullscreen();
                }
            }

            addNote(data = null) {
                this.log("Adding Note...");
                try {
                    const id = data ? data.id : Date.now().toString();
                    const note = new StickyNote(id, data, this);
                    this.notes.push(note);
                    this.container.appendChild(note.element);
                    this.save();
                    return note;
                } catch (e) {
                    this.log("Add Err: " + e.message);
                    console.error(e);
                }
            }

            removeNote(id) {
                this.notes = this.notes.filter(n => n.id !== id);
                this.save();
            }

            save() {
                const data = this.notes.map(n => n.serialize());
                localStorage.setItem('quick_stickies_v2', JSON.stringify(data));
            }

            load() {
                const json = localStorage.getItem('quick_stickies_v2');
                if (json) {
                    const data = JSON.parse(json);
                    data.forEach(d => this.addNote(d));
                }
                if (this.notes.length === 0) {
                    this.addNote({ x: 50, y: 70, w: 450, h: 450, color: 'yellow', isDraw: true });
                }
            }
        }

        class StickyNote {
            constructor(id, data, app) {
                this.id = id;
                this.app = app;
                this.x = data?.x || 50;
                this.y = data?.y || 70;
                this.w = data?.w || 450;
                this.h = data?.h || 450;
                this.color = data?.color || 'yellow';
                this.text = data?.text || "";
                this.drawing = data?.drawing || null;
                this.isDrawingMode = data?.isDraw !== undefined ? data.isDraw : true;

                // Ink Properties
                this.inkColor = data?.inkColor || '#222222';
                this.inkWidth = data?.inkWidth || 5;

                this.element = this.render();
                this.initInteraction();

                // Nuclear Delay for board sizing
                setTimeout(() => {
                    this.initCanvas();
                    this.updateModeUI();
                }, 200);
            }

            serialize() {
                return {
                    id: this.id, x: this.x, y: this.y, w: this.w, h: this.h,
                    color: this.color, text: this.text, drawing: this.drawing,
                    isDraw: this.isDrawingMode,
                    inkColor: this.inkColor, inkWidth: this.inkWidth
                };
            }

            render() {
                const el = document.createElement('div');
                el.className = `note color-${this.color}`;
                el.style.left = this.x + 'px';
                el.style.top = this.y + 'px';
                el.style.width = this.w + 'px';
                el.style.height = this.h + 'px';

                el.innerHTML = `
                    <div class="note-header">
                        <button class="icon-btn clear-btn" title="Clear Canvas">ðŸ§¹</button>
                        <div style="flex-grow:1; height:100%" class="drag-handle"></div>
                        
                        <!-- Pen Trigger -->
                        <div class="pen-controls" style="display:none; align-items:center; margin-right:10px;">
                            <button class="icon-btn ink-trigger" style="background:${this.inkColor}; border:1px solid #999; width:20px; height:20px; border-radius:50%;"></button>
                        </div>

                        <!-- Ink Popup (Hidden by default) -->
                        <div class="ink-popup" style="display:none;">
                            <div style="font-size:12px; font-weight:bold; color:#333;">Ink Color</div>
                            <div class="ink-row">
                                ${this.app.inkColors.map(c => `<div class="ink-dot ${c === this.inkColor ? 'active' : ''}" style="background:${c}" data-color="${c}"></div>`).join('')}
                            </div>
                            <div style="font-size:12px; font-weight:bold; color:#333; margin-top:5px;">Thickness</div>
                            <input type="range" class="ink-width-slider" min="1" max="15" value="${this.inkWidth}" style="width:100%;">
                            <button class="btn-main" style="width:100%; margin-top:5px; padding:4px;" class="ink-close-btn">DONE</button>
                        </div>

                        <div class="color-picker" style="display:flex; gap:4px; margin-right:8px;">
                            ${this.app.colors.map(c => `<div class="color-dot color-${c}" data-color="${c}"></div>`).join('')}
                        </div>
                        <button class="icon-btn close-btn">Ã—</button>
                    </div>
                    <div class="note-body">
                        <textarea class="note-textarea" placeholder="Type here...">${this.text}</textarea>
                        <canvas class="note-canvas"></canvas>
                    </div>
                    <div class="note-footer">
                        <button class="tool-btn type-btn">TYPE</button>
                        <button class="tool-btn draw-btn">DRAW</button>
                    </div>
                    <div class="resize-handle"></div>
                `;

                // Events
                el.querySelector('.close-btn').onclick = () => { if (confirm("Delete?")) { el.remove(); this.app.removeNote(this.id); } };
                el.querySelector('.clear-btn').onclick = () => { if (confirm("Clear?")) { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); this.drawing = null; this.app.save(); } };
                el.querySelectorAll('.color-dot').forEach(d => d.onclick = (e) => this.setColor(e.target.dataset.color));

                // Ink UI Logic
                const popup = el.querySelector('.ink-popup');
                const trigger = el.querySelector('.ink-trigger');
                const startPopup = (e) => { e.stopPropagation(); popup.style.display = popup.style.display === 'none' ? 'flex' : 'none'; };
                trigger.onclick = trigger.ontouchstart = startPopup;

                el.querySelector('.ink-close-btn').onclick = (e) => { e.stopPropagation(); popup.style.display = 'none'; };

                el.querySelectorAll('.ink-dot').forEach(dot => {
                    dot.onclick = (e) => {
                        e.stopPropagation();
                        // Reset actives
                        el.querySelectorAll('.ink-dot').forEach(d => d.classList.remove('active'));
                        dot.classList.add('active');
                        // Set color
                        this.inkColor = dot.dataset.color;
                        trigger.style.background = this.inkColor;
                        this.app.save();
                    };
                });

                const slider = el.querySelector('.ink-width-slider');
                slider.oninput = (e) => { this.inkWidth = parseInt(e.target.value); };
                slider.onchange = () => this.app.save();

                el.querySelector('.type-btn').onclick = () => { this.isDrawingMode = false; this.updateModeUI(); };
                el.querySelector('.draw-btn').onclick = () => { this.isDrawingMode = true; this.updateModeUI(); };
                el.querySelector('textarea').oninput = (e) => { this.text = e.target.value; };

                el.onmousedown = el.ontouchstart = () => this.focus();
                return el;
            }

            focus() {
                document.querySelectorAll('.note').forEach(n => n.classList.remove('active'));
                this.element.classList.add('active');
            }

            setColor(c) {
                this.app.colors.forEach(cl => this.element.classList.remove(`color-${cl}`));
                this.element.classList.add(`color-${c}`);
                this.color = c;
                this.app.save();
            }

            updateModeUI() {
                const txt = this.element.querySelector('.note-textarea');
                const canv = this.element.querySelector('.note-canvas');
                const tBtn = this.element.querySelector('.type-btn');
                const dBtn = this.element.querySelector('.draw-btn');
                const penControls = this.element.querySelector('.pen-controls');

                if (this.isDrawingMode) {
                    txt.style.display = 'none';
                    canv.style.display = 'block';
                    penControls.style.display = 'flex'; // Show Ink Controls
                    dBtn.classList.add('active');
                    tBtn.classList.remove('active');
                    this.resizeCanvas();
                } else {
                    txt.style.display = 'block';
                    canv.style.display = 'none';
                    penControls.style.display = 'none'; // Hide Ink Controls
                    tBtn.classList.add('active');
                    dBtn.classList.remove('active');
                }
                this.app.save();
            }

            initCanvas() {
                this.canvas = this.element.querySelector('.note-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();

                let drawing = false;
                let points = [];

                // Helper to get correct coordinates accounting for High DPI
                const getP = (e) => {
                    const r = this.canvas.getBoundingClientRect();
                    // Handle both Touch and Mouse
                    const cx = e.touches ? e.touches[0].clientX : e.clientX;
                    const cy = e.touches ? e.touches[0].clientY : e.clientY;

                    // Scale local coordinate to canvas internal resolution
                    const scaleX = this.canvas.width / r.width;
                    const scaleY = this.canvas.height / r.height;

                    return {
                        x: (cx - r.left) * scaleX,
                        y: (cy - r.top) * scaleY
                    };
                };

                const start = (e) => {
                    if (!this.isDrawingMode) return;
                    e.preventDefault();
                    drawing = true;
                    points = [];
                    const p = getP(e);
                    points.push(p);

                    this.ctx.beginPath();
                    this.ctx.lineWidth = (this.inkWidth || 3) * (window.devicePixelRatio || 1); // Scale thickness too
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    this.ctx.strokeStyle = this.inkColor || '#222';

                    // Dot
                    this.ctx.fillStyle = this.ctx.strokeStyle;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, this.ctx.lineWidth / 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.beginPath();
                };

                const move = (e) => {
                    if (!drawing) return;
                    e.preventDefault();

                    // Attempt to use Coalesced Events for smoother curves (if available)
                    // Echo Show Silk might support getCoalescedEvents on Pointer Events, 
                    // but for TouchEvents we just take the main one.
                    const p = getP(e);
                    points.push(p);

                    if (points.length < 3) return;

                    const i = points.length - 1;
                    const p0 = points[i - 2];
                    const p1 = points[i - 1];
                    const p2 = points[i];

                    const mid1 = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2 };
                    const mid2 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };

                    this.ctx.beginPath();
                    this.ctx.moveTo(mid1.x, mid1.y);
                    this.ctx.quadraticCurveTo(p1.x, p1.y, mid2.x, mid2.y);
                    this.ctx.stroke();
                };

                const stop = () => {
                    if (drawing) {
                        drawing = false;
                        this.drawing = this.canvas.toDataURL();
                        this.app.save();
                    }
                };

                this.canvas.addEventListener('touchstart', start, { passive: false });
                this.canvas.addEventListener('touchmove', move, { passive: false });
                document.addEventListener('touchend', stop);
                this.canvas.addEventListener('mousedown', start);
                this.canvas.addEventListener('mousemove', move);
                document.addEventListener('mouseup', stop);

                // Restore drawing if exists
                if (this.drawing) {
                    const img = new Image();
                    img.onload = () => this.ctx.drawImage(img, 0, 0);
                    img.src = this.drawing;
                }
            }

            resizeCanvas() {
                if (!this.canvas) return;
                const body = this.element.querySelector('.note-body');
                const cw = body.clientWidth;
                const ch = body.clientHeight;

                // Handle High DPI (Retina / Echo Show)
                // This makes the internal bitmap larger than the CSS display size
                const dpr = window.devicePixelRatio || 1;

                if (this.canvas.offsetWidth !== cw || this.canvas.offsetHeight !== ch) {
                    // Save content
                    const temp = this.canvas.toDataURL();

                    // Set CSS size (Display size)
                    this.canvas.style.width = cw + 'px';
                    this.canvas.style.height = ch + 'px';

                    // Set Internal Attributes (Bitmap size)
                    this.canvas.width = cw * dpr;
                    this.canvas.height = ch * dpr;

                    // Scale context to match
                    // We DON'T scale(dpr, dpr) here because we manually scale coordinates in getP
                    // allowing us to keep drawing logic explicit.
                    // Actually, standard practice is: ctx.scale(dpr, dpr).
                    // BUT, if we do that, we must ensure existing images are drawn correctly.
                    // Let's stick to manual coordinate scaling in getP to be safe with toDataURL restores.

                    // Restore
                    const img = new Image();
                    img.onload = () => {
                        this.ctx.drawImage(img, 0, 0, this.canvas.width, this.canvas.height); // Stretch to fit new resolution
                    };
                    img.src = temp;
                }
            }

            initInteraction() {
                const head = this.element.querySelector('.drag-handle');
                const res = this.element.querySelector('.resize-handle');
                let dragging = false, resizing = false, sx, sy, ox, oy, ow, oh;

                const startD = (e) => {
                    dragging = true; this.focus();
                    const ev = e.touches ? e.touches[0] : e;
                    sx = ev.clientX; sy = ev.clientY;
                    ox = this.x; oy = this.y;
                };

                const startR = (e) => {
                    e.stopPropagation(); resizing = true;
                    const ev = e.touches ? e.touches[0] : e;
                    sx = ev.clientX; sy = ev.clientY;
                    ow = this.w; oh = this.h;
                };

                const move = (e) => {
                    const ev = e.touches ? e.touches[0] : e;
                    if (dragging) {
                        this.x = ox + (ev.clientX - sx);
                        this.y = oy + (ev.clientY - sy);
                        this.element.style.left = this.x + 'px';
                        this.element.style.top = this.y + 'px';
                    }
                    if (resizing) {
                        this.w = Math.max(200, ow + (ev.clientX - sx));
                        this.h = Math.max(200, oh + (ev.clientY - sy));
                        this.element.style.width = this.w + 'px';
                        this.element.style.height = this.h + 'px';
                        this.resizeCanvas();
                    }
                };

                const stop = () => { dragging = resizing = false; this.app.save(); };

                head.onmousedown = head.ontouchstart = startD;
                res.onmousedown = res.ontouchstart = startR;
                window.addEventListener('mousemove', move);
                window.addEventListener('touchmove', move, { passive: false });
                window.addEventListener('mouseup', stop);
                window.addEventListener('touchend', stop);
            }
        }

        const app = new App();
        window.app = app; // Ensure global access
    </script>
</body>

</html>