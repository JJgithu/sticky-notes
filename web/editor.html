<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- PWA / Fullscreen Mobile Tags -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#202020">
    <title>Quick Stickies</title>
    <style>
        /* --- Windows 11 / Fluent Design System --- */
        :root {
            --bg-color: #202020;
            /* Dark Desktop Background */
            --shadow-elevation: 0 8px 20px rgba(0, 0, 0, 0.3);
            --header-height: 32px;
            --footer-height: 48px;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 20px 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            /* Prevent body scroll, notes move freely */
            touch-action: none;
            user-select: none;
            height: 100vh;
            width: 100vw;
        }

        /* --- Toolbar (Desktop Style) --- */
        #app-toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 9999;
            box-shadow: 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .app-title {
            color: white;
            font-weight: 600;
            font-size: 18px;
        }

        .btn-main {
            background-color: #0078D4;
            /* Windows Blue */
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-main:active {
            background-color: #005a9e;
        }

        /* --- Sticky Note Container --- */
        .note {
            position: absolute;
            display: flex;
            flex-direction: column;
            border-radius: 4px;
            box-shadow: var(--shadow-elevation);
            border: 1px solid rgba(0, 0, 0, 0.1);
            overflow: hidden;
            transition: box-shadow 0.2s, transform 0.1s;
        }

        .note.active {
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        /* --- Colors (Windows 11 Palette) --- */
        .color-yellow {
            background-color: #fff7d1;
        }

        .color-green {
            background-color: #e4ffc1;
        }

        .color-pink {
            background-color: #ffdae9;
        }

        .color-purple {
            background-color: #e8dff5;
        }

        .color-blue {
            background-color: #e2f1ff;
        }

        .color-charcoal {
            background-color: #333333;
            color: white;
        }

        .note-header {
            height: 30px;
            background: rgba(0, 0, 0, 0.05);
            display: flex;
            align-items: center;
            padding: 0 5px;
            cursor: grab;
            user-select: none;
        }

        .drag-zone {
            flex-grow: 1;
            height: 100%;
        }

        .close-btn,
        .menu-btn,
        .icon-btn {
            background: none;
            border: none;
            font-size: 16px;
            cursor: pointer;
            opacity: 0.6;
            padding: 0 5px;
            color: inherit;
        }

        .close-btn:hover,
        .menu-btn:hover,
        .icon-btn:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }

        /* --- Content Layers --- */
        .note-body {
            position: relative;
            flex-grow: 1;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.2);
            /* Slight tint for writing area */
        }

        .note-textarea {
            width: 100%;
            height: 100%;
            border: none;
            resize: none;
            background: transparent;
            font-family: 'Segoe UI', sans-serif;
            font-size: 18px;
            color: #222;
            padding: 10px;
            box-sizing: border-box;
            outline: none;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            /* Default: Typing is top */
        }

        .note-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
            pointer-events: none;
            /* Default: Passthrough */
            touch-action: none;
            /* Crucial for drawing */
        }

        /* --- Drawing Mode Active --- */
        .note.drawing-mode .note-textarea {
            z-index: 5;
            /* Move text behind */
            pointer-events: none;
        }

        .note.drawing-mode .note-textarea::placeholder {
            color: transparent;
            /* Hide placeholder */
        }

        .note.drawing-mode .note-canvas {
            z-index: 10;
            /* Move canvas to front */
            pointer-events: auto;
            /* Enable drawing */
            cursor: crosshair;
        }

        .note.drawing-mode .note-body {
            box-shadow: inset 0 0 0 2px rgba(0, 120, 212, 0.5);
        }

        /* --- Footer / Tools --- */
        .note-footer {
            height: var(--footer-height);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.03);
            border-top: 1px solid rgba(0, 0, 0, 0.05);
            gap: 10px;
        }

        .tool-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            padding: 6px 10px;
            border-radius: 4px;
            color: inherit;
            opacity: 0.7;
            font-weight: 500;
        }

        .tool-btn.active {
            background: rgba(0, 0, 0, 0.2);
            opacity: 1;
        }

        .tool-btn:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        /* --- Resize Handle --- */
        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 40px;
            height: 40px;
            cursor: nwse-resize;
            background: linear-gradient(135deg, transparent 70%, rgba(0, 0, 0, 0.2) 70%);
            z-index: 50;
        }

        /* --- Context Menu (Colors) --- */
        .context-menu {
            position: absolute;
            top: 35px;
            right: 10px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            padding: 8px;
            display: flex;
            gap: 5px;
            z-index: 100;
            display: none;
        }

        .context-menu.visible {
            display: flex;
        }

        .color-dot {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .color-dot:hover {
            transform: scale(1.1);
        }

        /* --- Status Bar --- */
        #status-bar {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            transition: opacity 0.5s;
        }
    </style>
</head>

<body>

    <div id="app-toolbar">
        <div class="app-title">Quick Stickies</div>
        <div style="display:flex; gap:10px;">
            <button class="btn-main" style="background:#444" onclick="app.toggleFullscreen()">FULLSCREEN</button>
            <button class="btn-main" onclick="app.addNote()">+ New Note</button>
        </div>
    </div>

    <div id="status-bar">Ready</div>

    <!-- DEBUG CONSOLE -->
    <div id="debug-console"
        style="position:fixed; top:50px; left:10px; width:200px; height:300px; background:rgba(0,0,0,0.8); color:#0f0; font-family:monospace; font-size:10px; overflow-y:auto; z-index:99999; pointer-events:none; display:none;">
    </div>

    <!-- Notes Container -->
    <div id="board"></div>

    <script>
        // --- Application State ---
        class App {
            constructor() {
                this.notes = [];
                this.container = document.getElementById('board');
                this.colors = [
                    { name: 'yellow', hex: '#fff7d1' },
                    { name: 'green', hex: '#e4ffc1' },
                    { name: 'pink', hex: '#ffdae9' },
                    { name: 'purple', hex: '#e8dff5' },
                    { name: 'blue', hex: '#e2f1ff' },
                    { name: 'charcoal', hex: '#333333' }
                ];

                // Load from storage
                this.load();

                // Auto-save loop
                setInterval(() => this.save(), 2000);
            }

            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        this.log(`Fullscreen blocked: ${err.message}`);
                    });
                } else {
                    document.exitFullscreen();
                }
            }

            log(msg) {
                const el = document.getElementById('status-bar');
                if (el) {
                    el.innerText = msg;
                    el.style.opacity = 1;
                }
                console.log(msg);

                // Debug to screen
                const dbg = document.getElementById('debug-console');
                if (dbg) {
                    dbg.style.display = 'block'; // Show if used
                    const line = document.createElement('div');
                    line.innerText = `> ${msg}`;
                    dbg.prepend(line);
                    if (dbg.children.length > 20) dbg.lastChild.remove();
                }
            }

            addNote(data = null) {
                const id = data ? data.id : Date.now().toString();
                const note = new StickyNote(id, data, this);
                this.notes.push(note);
                this.container.appendChild(note.element);
                this.log('Note added');
                this.save();
                return note;
            }

            removeNote(id) {
                this.notes = this.notes.filter(n => n.id !== id);
                this.save();
            }

            save() {
                const data = this.notes.map(n => n.serialize());
                localStorage.setItem('quick_stickies_v1', JSON.stringify(data));
                this.log(`Saved ${this.notes.length} notes.`);
            }

            load() {
                try {
                    const json = localStorage.getItem('quick_stickies_v1');
                    if (json) {
                        const data = JSON.parse(json);
                        if (Array.isArray(data) && data.length > 0) {
                            data.forEach(d => this.addNote(d));
                            return;
                        }
                    }
                } catch (e) {
                    console.error("Load failed", e);
                }
                // Default if empty - Start with ONE big empty note
                if (this.notes.length === 0) {
                    this.addNote({
                        text: "",
                        x: 50, y: 50, w: 450, h: 450, color: 'yellow'
                    });
                }
            }
        }

        // --- Sticky Note Component ---
        class StickyNote {
            constructor(id, data, app) {
                this.id = id;
                this.app = app;
                // Defaults: Bigger (450x450), Empty Text, Drawing Mode by default (if new)
                this.x = data && data.x ? data.x : Math.random() * (window.innerWidth - 400);
                this.y = data && data.y ? data.y : Math.random() * (window.innerHeight - 400) + 50;
                this.width = data && data.w ? data.w : 450;
                this.height = data && data.h ? data.h : 450;
                this.color = data && data.color ? data.color : this.app.colors[0].name; // Default Yellow
                this.textContent = data && data.text ? data.text : '';
                this.drawingData = data && data.drawing ? data.drawing : null;

                // If it's a fresh note (no data), default to Drawing Mode. 
                // If loading from save, default to Text mode unless they had a drawing? 
                // User asked for Drawing Mode standard.
                this.isDrawingMode = true;

                this.element = this.render();
                this.initInteraction();
                this.initCanvas();

                // Set initial mode UI
                const typeBtn = this.element.querySelector('.type-btn');
                const drawBtn = this.element.querySelector('.draw-btn');
                this.setMode(this.isDrawingMode, typeBtn, drawBtn);
            }

            render() {
                const el = document.createElement('div');
                el.className = `note color-${this.color}`;
                el.style.left = `${this.x}px`;
                el.style.top = `${this.y}px`;
                el.style.width = `${this.width}px`;
                el.style.height = `${this.height}px`;
                el.id = `note-${this.id}`;

                el.innerHTML = `
                    <div class="note-header">
                        <!-- Eraser / Clear Button -->
                        <button class="icon-btn clear-btn" title="Clear Drawing" style="margin-right:5px">ðŸ§¹</button>
                        
                        <div style="flex-grow:1; height:100%" class="drag-zone"></div>
                        
                        <div class="context-menu" id="menu-${this.id}">
                            ${this.app.colors.map(c => `<div class="color-dot" style="background:${c.hex}" data-color="${c.name}"></div>`).join('')}
                        </div>
                        <button class="menu-btn" onclick="document.getElementById('menu-${this.id}').classList.toggle('visible')">ðŸŽ¨</button>
                        <button class="close-btn" title="Delete Note">Ã—</button>
                    </div>
                    <div class="note-body">
                        <textarea class="note-textarea" spellcheck="false" placeholder="Type here...">${this.textContent}</textarea>
                        <canvas class="note-canvas"></canvas>
                    </div>
                    <div class="note-footer">
                        <button class="tool-btn type-btn">T Type</button>
                        <button class="tool-btn draw-btn">âœŽ Draw</button>
                    </div>
                    <div class="resize-handle"></div>
                `;

                // Add Event Listeners
                el.querySelector('.close-btn').onclick = () => {
                    if (confirm("Delete this note?")) {
                        el.remove();
                        this.app.removeNote(this.id);
                    }
                };

                el.querySelector('.clear-btn').onclick = () => {
                    if (confirm("Clear current drawing?")) {
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                        this.drawingData = null;
                        this.app.save();
                    }
                };

                // Color Picker
                el.querySelectorAll('.color-dot').forEach(dot => {
                    dot.onclick = (e) => {
                        this.setColor(e.target.dataset.color);
                        el.querySelector('.context-menu').classList.remove('visible');
                    };
                });

                // Mode Toggles
                const typeBtn = el.querySelector('.type-btn');
                const drawBtn = el.querySelector('.draw-btn');

                const handleMode = (e, isDrawing) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.setMode(isDrawing, typeBtn, drawBtn);
                };

                typeBtn.addEventListener('mousedown', (e) => handleMode(e, false));
                typeBtn.addEventListener('touchstart', (e) => handleMode(e, false), { passive: false });

                drawBtn.addEventListener('mousedown', (e) => handleMode(e, true));
                drawBtn.addEventListener('touchstart', (e) => handleMode(e, true), { passive: false });

                // Text Input
                el.querySelector('textarea').oninput = (e) => {
                    this.textContent = e.target.value;
                };

                // Bring to front on click
                el.onmousedown = () => this.focus();
                el.ontouchstart = () => this.focus();

                return el;
            }

            focus() {
                document.querySelectorAll('.note').forEach(n => n.classList.remove('active'));
                this.element.classList.add('active');
            }

            setColor(cls) {
                this.app.colors.forEach(c => this.element.classList.remove(`color-${c.name}`));
                this.element.classList.add(`color-${cls}`);
                this.color = cls;
                this.app.save();
            }

            setMode(isDrawing, typeBtn, drawBtn) {
                this.isDrawingMode = isDrawing;
                const textarea = this.element.querySelector('.note-textarea');
                const canvas = this.element.querySelector('.note-canvas');

                if (isDrawing) {
                    this.element.classList.add('drawing-mode');
                    drawBtn.classList.add('active');
                    typeBtn.classList.remove('active');
                    textarea.style.display = 'none'; // NUCLEAR FIX: Hide the textarea
                    canvas.style.display = 'block';
                    // Re-sync canvas size just in case
                    setTimeout(() => this.resizeCanvas(), 50);
                } else {
                    this.element.classList.remove('drawing-mode');
                    drawBtn.classList.remove('active');
                    typeBtn.classList.add('active');
                    textarea.style.display = 'block';
                    // canvas.style.display = 'none'; // Keep visible to see drawing? No, let's keep it under.
                }
            }

            initCanvas() {
                this.canvas = this.element.querySelector('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();

                let isDrawing = false;

                // --- POINTER EVENTS (Unified Mouse/Touch for Echo Show) ---
                const start = (e) => {
                    if (!this.isDrawingMode) return;
                    e.preventDefault();

                    this.app.log(`Ptr: ${Math.round(e.clientX)},${Math.round(e.clientY)}`);

                    isDrawing = true;
                    // Capture pointer to track outside canvas & prevent scrolling
                    if (e.target.setPointerCapture) {
                        e.target.setPointerCapture(e.pointerId);
                    }

                    const pos = this.getPos(e);

                    this.ctx.beginPath();
                    this.ctx.moveTo(pos.x, pos.y);
                    this.ctx.lineWidth = 3;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    this.ctx.strokeStyle = this.color === 'charcoal' ? '#ffffff' : '#333333';

                    // Instant Feedback Dot
                    this.ctx.fillStyle = this.ctx.strokeStyle;
                    this.ctx.fillRect(pos.x - 1, pos.y - 1, 2, 2);
                };

                const move = (e) => {
                    if (!isDrawing) return;
                    e.preventDefault();

                    const pos = this.getPos(e);
                    this.ctx.lineTo(pos.x, pos.y);
                    this.ctx.stroke();
                };

                const end = (e) => {
                    if (isDrawing) {
                        isDrawing = false;
                        if (e.target.releasePointerCapture) {
                            e.target.releasePointerCapture(e.pointerId);
                        }
                        this.drawingData = this.canvas.toDataURL();
                        this.app.save();
                        this.app.log('Save');
                    }
                };

                // Use Pointer Events for everything (Mouse + Touch)
                // This bypasses the specific "touchstart" issues on Silk
                this.canvas.addEventListener('pointerdown', start);
                this.canvas.addEventListener('pointermove', move);
                this.canvas.addEventListener('pointerup', end);
                this.canvas.addEventListener('pointercancel', end);

                // Load existing
                if (this.drawingData) {
                    const img = new Image();
                    img.onload = () => this.ctx.drawImage(img, 0, 0);
                    img.src = this.drawingData;
                }
            }

            resizeCanvas() {
                const body = this.element.querySelector('.note-body');
                const temp = this.canvas.toDataURL();
                this.canvas.width = body.clientWidth;
                this.canvas.height = body.clientHeight;

                // Restore
                const img = new Image();
                img.onload = () => this.ctx.drawImage(img, 0, 0);
                img.src = temp;
            }

            getPos(e) {
                const rect = this.canvas.getBoundingClientRect();
                let clientX, clientY;

                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
            }

            initInteraction() {
                // --- Dragging ---
                const header = this.element.querySelector('.note-header');
                let isDragging = false, startX, startY, initX, initY;

                const startDrag = (e) => {
                    if (e.target.tagName === 'BUTTON' || e.target.classList.contains('color-dot')) return;
                    isDragging = true;
                    this.focus();
                    const evt = e.touches ? e.touches[0] : e;
                    startX = evt.clientX;
                    startY = evt.clientY;
                    initX = this.x;
                    initY = this.y;
                    document.body.style.cursor = 'grabbing';
                };

                const drag = (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    const evt = e.touches ? e.touches[0] : e;
                    const dx = evt.clientX - startX;
                    const dy = evt.clientY - startY;
                    this.x = initX + dx;
                    this.y = initY + dy;
                    this.element.style.left = `${this.x}px`;
                    this.element.style.top = `${this.y}px`;
                };

                const stopDrag = () => {
                    if (isDragging) {
                        isDragging = false;
                        document.body.style.cursor = 'default';
                        this.app.save();
                    }
                };

                header.addEventListener('mousedown', startDrag);
                window.addEventListener('mousemove', drag);
                window.addEventListener('mouseup', stopDrag);

                header.addEventListener('touchstart', startDrag);
                // Passive false to prevent scrolling while dragging
                window.addEventListener('touchmove', drag, { passive: false });
                window.addEventListener('touchend', stopDrag);


                // --- Resizing ---
                const handle = this.element.querySelector('.resize-handle');
                let isResizing = false;

                const startResize = (e) => {
                    e.stopPropagation();
                    isResizing = true;
                    const evt = e.touches ? e.touches[0] : e;
                    startX = evt.clientX;
                    startY = evt.clientY;
                    initX = this.width;
                    initY = this.height;
                };

                const resize = (e) => {
                    if (!isResizing) return;
                    e.preventDefault();
                    const evt = e.touches ? e.touches[0] : e;
                    const w = initX + (evt.clientX - startX);
                    const h = initY + (evt.clientY - startY);

                    if (w > 200) { this.width = w; this.element.style.width = w + 'px'; }
                    if (h > 200) { this.height = h; this.element.style.height = h + 'px'; }

                    // Throttled resizeCanvas call? For now direct call is fine
                    this.resizeCanvas();
                };

                const stopResize = () => {
                    if (isResizing) {
                        isResizing = false;
                        this.app.save();
                    }
                };

                handle.addEventListener('mousedown', startResize);
                window.addEventListener('mousemove', resize);
                window.addEventListener('mouseup', stopResize);

                handle.addEventListener('touchstart', startResize);
                window.addEventListener('touchmove', resize, { passive: false });
                window.addEventListener('touchend', stopResize);
            }

            serialize() {
                return {
                    id: this.id,
                    x: this.x,
                    y: this.y,
                    w: this.width,
                    h: this.height,
                    color: this.color,
                    text: this.textContent,
                    drawing: this.drawingData
                };
            }
        }

        // --- Init ---
        const app = new App();

    </script>
</body>

</html>