<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- PWA / Fullscreen Mobile Tags -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#202020">
    <title>Quick Stickies</title>
    <style>
        /* --- Windows 11 / Fluent Design System --- */
        :root {
            --bg-color: #202020;
            /* Dark Desktop Background */
            --shadow-elevation: 0 8px 20px rgba(0, 0, 0, 0.3);
            --header-height: 32px;
            --footer-height: 48px;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 20px 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            /* Prevent body scroll, notes move freely */
            touch-action: none;
            user-select: none;
            height: 100vh;
            width: 100vw;
        }

        /* --- Toolbar (Desktop Style) --- */
        #app-toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 9999;
            box-shadow: 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .app-title {
            color: white;
            font-weight: 600;
            font-size: 18px;
        }

        .btn-main {
            background-color: #0078D4;
            /* Windows Blue */
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-main:active {
            background-color: #005a9e;
        }

        /* --- Sticky Note Container --- */
        .note {
            position: absolute;
            display: flex;
            flex-direction: column;
            border-radius: 4px;
            box-shadow: var(--shadow-elevation);
            border: 1px solid rgba(0, 0, 0, 0.1);
            overflow: hidden;
            transition: box-shadow 0.2s, transform 0.1s;
        }

        .note.active {
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        /* --- Colors (Windows 11 Palette) --- */
        .color-yellow {
            background-color: #fff7d1;
        }

        .color-green {
            background-color: #e4ffc1;
        }

        .color-pink {
            background-color: #ffdae9;
        }

        .color-purple {
            background-color: #e8dff5;
        }

        .color-blue {
            background-color: #e2f1ff;
        }

        .color-charcoal {
            background-color: #333333;
            color: white;
        }

        .note-header {
            height: var(--header-height);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 8px;
            background: rgba(0, 0, 0, 0.05);
            /* Slight tint */
            cursor: grab;
        }

        .note-header:active {
            cursor: grabbing;
        }

        .close-btn,
        .menu-btn {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            opacity: 0.6;
            padding: 0 4px;
            color: inherit;
        }

        .close-btn:hover,
        .menu-btn:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }

        .note-body {
            flex-grow: 1;
            position: relative;
            background: transparent;
        }

        /* --- Content Layers --- */
        .note-textarea {
            width: 100%;
            height: 100%;
            border: none;
            resize: none;
            background: transparent;
            font-family: 'Segoe UI', sans-serif;
            font-size: 16px;
            padding: 12px;
            box-sizing: border-box;
            outline: none;
            color: inherit;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
        }

        .note-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 20;
            pointer-events: none;
            /* Default: Let clicks pass to text */
            touch-action: none;
            /* Crucial for drawing */
        }

        .drawing-mode .note-canvas {
            pointer-events: auto;
            /* Capture clicks when drawing */
            cursor: crosshair;
        }

        .drawing-mode .note-textarea {
            opacity: 0.8;
            /* Dim text slightly when drawing */
        }

        /* --- Footer / Tools --- */
        .note-footer {
            height: var(--footer-height);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.03);
            border-top: 1px solid rgba(0, 0, 0, 0.05);
            gap: 10px;
        }

        .tool-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            padding: 6px 10px;
            border-radius: 4px;
            color: inherit;
            opacity: 0.7;
            font-weight: 500;
        }

        .tool-btn.active {
            background: rgba(0, 0, 0, 0.2);
            opacity: 1;
        }

        .tool-btn:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        /* --- Resize Handle --- */
        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 40px;
            height: 40px;
            cursor: nwse-resize;
            background: linear-gradient(135deg, transparent 70%, rgba(0, 0, 0, 0.2) 70%);
            z-index: 50;
        }

        /* --- Context Menu (Colors) --- */
        .context-menu {
            position: absolute;
            top: 35px;
            right: 10px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            padding: 8px;
            display: flex;
            gap: 5px;
            z-index: 100;
            display: none;
        }

        .context-menu.visible {
            display: flex;
        }

        .color-dot {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .color-dot:hover {
            transform: scale(1.1);
        }

        /* --- Status Bar --- */
        #status-bar {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            transition: opacity 0.5s;
        }
    </style>
</head>

<body>

    <div id="app-toolbar">
        <div class="app-title">Quick Stickies</div>
        <button class="btn-main" onclick="app.addNote()">+ New Note</button>
    </div>

    <div id="status-bar">Ready</div>

    <!-- Notes Container -->
    <div id="board"></div>

    <script>
        // --- Application State ---
        class App {
            constructor() {
                this.notes = [];
                this.container = document.getElementById('board');
                this.colors = [
                    { name: 'yellow', hex: '#fff7d1' },
                    { name: 'green', hex: '#e4ffc1' },
                    { name: 'pink', hex: '#ffdae9' },
                    { name: 'purple', hex: '#e8dff5' },
                    { name: 'blue', hex: '#e2f1ff' },
                    { name: 'charcoal', hex: '#333333' }
                ];

                // Load from storage
                this.load();

                // Auto-save loop
                setInterval(() => this.save(), 2000);
            }

            log(msg) {
                const el = document.getElementById('status-bar');
                if (el) {
                    el.innerText = msg;
                    el.style.opacity = 1;
                }
                console.log(msg);
            }

            addNote(data = null) {
                const id = data ? data.id : Date.now().toString();
                const note = new StickyNote(id, data, this);
                this.notes.push(note);
                this.container.appendChild(note.element);
                this.log('Note added');
                this.save();
                return note;
            }

            removeNote(id) {
                this.notes = this.notes.filter(n => n.id !== id);
                this.save();
            }

            save() {
                const data = this.notes.map(n => n.serialize());
                localStorage.setItem('quick_stickies_v1', JSON.stringify(data));
                this.log(`Saved ${this.notes.length} notes.`);
            }

            load() {
                try {
                    const json = localStorage.getItem('quick_stickies_v1');
                    if (json) {
                        const data = JSON.parse(json);
                        if (Array.isArray(data) && data.length > 0) {
                            data.forEach(d => this.addNote(d));
                            return;
                        }
                    }
                } catch (e) {
                    console.error("Load failed", e);
                }
                // Default if empty - Start with ONE big empty note
                if (this.notes.length === 0) {
                    this.addNote({
                        text: "",
                        x: 50, y: 50, w: 450, h: 450, color: 'yellow'
                    });
                }
            }
        }

        // --- Sticky Note Component ---
        class StickyNote {
            constructor(id, data, app) {
                this.id = id;
                this.app = app;
                // Defaults: Bigger (450x450), Empty Text, Drawing Mode by default (if new)
                this.x = data && data.x ? data.x : Math.random() * (window.innerWidth - 400);
                this.y = data && data.y ? data.y : Math.random() * (window.innerHeight - 400) + 50;
                this.width = data && data.w ? data.w : 450;
                this.height = data && data.h ? data.h : 450;
                this.color = data && data.color ? data.color : this.app.colors[0].name; // Default Yellow
                this.textContent = data && data.text ? data.text : '';
                this.drawingData = data && data.drawing ? data.drawing : null;

                // If it's a fresh note (no data), default to Drawing Mode. 
                // If loading from save, default to Text mode unless they had a drawing? 
                // User asked for Drawing Mode standard.
                this.isDrawingMode = true;

                this.element = this.render();
                this.initInteraction();
                this.initCanvas();

                // Set initial mode UI
                const typeBtn = this.element.querySelector('.type-btn');
                const drawBtn = this.element.querySelector('.draw-btn');
                this.setMode(this.isDrawingMode, typeBtn, drawBtn);
            }

            render() {
                const el = document.createElement('div');
                el.className = `note color-${this.color}`;
                el.style.left = `${this.x}px`;
                el.style.top = `${this.y}px`;
                el.style.width = `${this.width}px`;
                el.style.height = `${this.height}px`;
                el.id = `note-${this.id}`;

                el.innerHTML = `
                    <div class="note-header">
                        <span style="font-size:12px; font-weight:bold; opacity:0.5;">+</span>
                        <div style="flex-grow:1; height:100%"></div>
                        <div class="context-menu" id="menu-${this.id}">
                            ${this.app.colors.map(c => `<div class="color-dot" style="background:${c.hex}" data-color="${c.name}"></div>`).join('')}
                        </div>
                        <button class="menu-btn" onclick="document.getElementById('menu-${this.id}').classList.toggle('visible')">‚Ä¢‚Ä¢‚Ä¢</button>
                        <button class="close-btn">√ó</button>
                    </div>
                    <div class="note-body">
                        <textarea class="note-textarea" spellcheck="false" placeholder="Type here...">${this.textContent}</textarea>
                        <canvas class="note-canvas"></canvas>
                    </div>
                    <div class="note-footer">
                        <button class="tool-btn type-btn">T Type</button>
                        <button class="tool-btn draw-btn">‚úé Draw</button>
                        <button class="tool-btn clear-btn" style="margin-left:auto; font-size:12px">üóëÔ∏è</button>
                    </div>
                    <div class="resize-handle"></div>
                `;

                // Add Event Listeners
                el.querySelector('.close-btn').onclick = () => {
                    if (confirm("Delete this note?")) {
                        el.remove();
                        this.app.removeNote(this.id);
                    }
                };

                el.querySelector('.clear-btn').onclick = () => {
                    if (confirm("Clear drawing?")) {
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                        this.drawingData = null;
                        this.app.save();
                    }
                };

                // Color Picker
                el.querySelectorAll('.color-dot').forEach(dot => {
                    dot.onclick = (e) => {
                        this.setColor(e.target.dataset.color);
                        el.querySelector('.context-menu').classList.remove('visible');
                    };
                });

                // Mode Toggles
                const typeBtn = el.querySelector('.type-btn');
                const drawBtn = el.querySelector('.draw-btn');

                typeBtn.onclick = () => this.setMode(false, typeBtn, drawBtn);
                drawBtn.onclick = () => this.setMode(true, typeBtn, drawBtn);

                // Text Input
                el.querySelector('textarea').oninput = (e) => {
                    this.textContent = e.target.value;
                };

                // Bring to front on click
                el.onmousedown = () => this.focus();
                el.ontouchstart = () => this.focus();

                return el;
            }

            focus() {
                document.querySelectorAll('.note').forEach(n => n.classList.remove('active'));
                this.element.classList.add('active');
            }

            setColor(cls) {
                this.app.colors.forEach(c => this.element.classList.remove(`color-${c.name}`));
                this.element.classList.add(`color-${cls}`);
                this.color = cls;
                this.app.save();
            }

            setMode(isDrawing, typeBtn, drawBtn) {
                this.isDrawingMode = isDrawing;
                if (isDrawing) {
                    this.element.classList.add('drawing-mode');
                    drawBtn.classList.add('active');
                    typeBtn.classList.remove('active');
                } else {
                    this.element.classList.remove('drawing-mode');
                    drawBtn.classList.remove('active');
                    typeBtn.classList.add('active');
                }
            }

            initCanvas() {
                this.canvas = this.element.querySelector('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();

                let isDrawing = false;
                let points = [];

                // Helper for quadratic curve (Smoothing)
                const drawCurve = (ctx, pts) => {
                    if (pts.length < 3) return;
                    ctx.beginPath();
                    ctx.moveTo(pts[0].x, pts[0].y);
                    for (let i = 1; i < pts.length - 2; i++) {
                        const xc = (pts[i].x + pts[i + 1].x) / 2;
                        const yc = (pts[i].y + pts[i + 1].y) / 2;
                        ctx.quadraticCurveTo(pts[i].x, pts[i].y, xc, yc);
                    }
                    // For the last 2 points
                    const last = pts[pts.length - 1];
                    const secondLast = pts[pts.length - 2];
                    ctx.quadraticCurveTo(secondLast.x, secondLast.y, last.x, last.y);
                    ctx.stroke();
                };

                const start = (e) => {
                    if (!this.isDrawingMode) return;
                    // Aggressively prevent default to stop scrolling/selection
                    if (e.cancelable) e.preventDefault();

                    isDrawing = true;
                    points = []; // Reset points

                    const pos = this.getPos(e);
                    points.push(pos);

                    this.ctx.strokeStyle = this.color === 'charcoal' ? '#ffffff' : '#333333';
                    this.ctx.lineWidth = 3;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';

                    // Draw single dot
                    this.ctx.beginPath();
                    this.ctx.arc(pos.x, pos.y, 1.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.beginPath(); // Begin path for moving
                };

                const move = (e) => {
                    if (!isDrawing) return;
                    if (e.cancelable) e.preventDefault();

                    const pos = this.getPos(e);
                    points.push(pos);

                    // Basic line drawing for responsiveness, could optimize by only drawing curves on end
                    // But to see real-time, we use simple lines or basic curves
                    if (points.length > 2) {
                        // Clear rect and redraw curve? No, too slow. 
                        // Just draw segment.
                        // For true smoothing we need to redraw the path, but that's expensive for a sticky note.
                        // We will use "Midpoint" strategy on the fly.
                        const p1 = points[points.length - 2];
                        const p2 = points[points.length - 1];
                        const mid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };

                        this.ctx.beginPath();
                        this.ctx.moveTo(p1.x, p1.y);
                        this.ctx.quadraticCurveTo(p1.x, p1.y, mid.x, mid.y); // Actually this isn't quite right for realtime. 
                        // Fallback to lineTo for performance, but shorter segments.
                        this.ctx.lineTo(pos.x, pos.y);
                        this.ctx.stroke();
                    }
                };

                const end = (e) => {
                    if (isDrawing) {
                        isDrawing = false;
                        this.drawingData = this.canvas.toDataURL();
                        this.app.save();
                    }
                };

                this.canvas.addEventListener('mousedown', start);
                this.canvas.addEventListener('mousemove', move);
                this.canvas.addEventListener('mouseup', end);

                // IMPORTANT: Passive false to allow preventDefault
                this.canvas.addEventListener('touchstart', start, { passive: false });
                this.canvas.addEventListener('touchmove', move, { passive: false });
                this.canvas.addEventListener('touchend', end);

                // Load existing drawing
                if (this.drawingData) {
                    const img = new Image();
                    img.onload = () => this.ctx.drawImage(img, 0, 0);
                    img.src = this.drawingData;
                }
            }

            resizeCanvas() {
                const body = this.element.querySelector('.note-body');
                const temp = this.canvas.toDataURL(); // Save current content
                this.canvas.width = body.clientWidth;
                this.canvas.height = body.clientHeight;

                // Restore content after resize
                const img = new Image();
                img.onload = () => this.ctx.drawImage(img, 0, 0);
                img.src = temp;
            }

            getPos(e) {
                const rect = this.canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
            }

            initInteraction() {
                // --- Dragging ---
                const header = this.element.querySelector('.note-header');
                let isDragging = false, startX, startY, initX, initY;

                const startDrag = (e) => {
                    if (e.target.tagName === 'BUTTON' || e.target.classList.contains('color-dot')) return;
                    isDragging = true;
                    this.focus();
                    const evt = e.touches ? e.touches[0] : e;
                    startX = evt.clientX;
                    startY = evt.clientY;
                    initX = this.x;
                    initY = this.y;
                    document.body.style.cursor = 'grabbing';
                };

                const drag = (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    const evt = e.touches ? e.touches[0] : e;
                    const dx = evt.clientX - startX;
                    const dy = evt.clientY - startY;
                    this.x = initX + dx;
                    this.y = initY + dy;
                    this.element.style.left = `${this.x}px`;
                    this.element.style.top = `${this.y}px`;
                };

                const stopDrag = () => {
                    if (isDragging) {
                        isDragging = false;
                        document.body.style.cursor = 'default';
                        this.app.save();
                    }
                };

                header.addEventListener('mousedown', startDrag);
                window.addEventListener('mousemove', drag);
                window.addEventListener('mouseup', stopDrag);

                header.addEventListener('touchstart', startDrag);
                // Passive false to prevent scrolling while dragging
                window.addEventListener('touchmove', drag, { passive: false });
                window.addEventListener('touchend', stopDrag);


                // --- Resizing ---
                const handle = this.element.querySelector('.resize-handle');
                let isResizing = false;

                const startResize = (e) => {
                    e.stopPropagation();
                    isResizing = true;
                    const evt = e.touches ? e.touches[0] : e;
                    startX = evt.clientX;
                    startY = evt.clientY;
                    initX = this.width;
                    initY = this.height;
                };

                const resize = (e) => {
                    if (!isResizing) return;
                    e.preventDefault();
                    const evt = e.touches ? e.touches[0] : e;
                    const w = initX + (evt.clientX - startX);
                    const h = initY + (evt.clientY - startY);

                    if (w > 200) { this.width = w; this.element.style.width = w + 'px'; }
                    if (h > 200) { this.height = h; this.element.style.height = h + 'px'; }

                    // Throttled resizeCanvas call? For now direct call is fine
                    this.resizeCanvas();
                };

                const stopResize = () => {
                    if (isResizing) {
                        isResizing = false;
                        this.app.save();
                    }
                };

                handle.addEventListener('mousedown', startResize);
                window.addEventListener('mousemove', resize);
                window.addEventListener('mouseup', stopResize);

                handle.addEventListener('touchstart', startResize);
                window.addEventListener('touchmove', resize, { passive: false });
                window.addEventListener('touchend', stopResize);
            }

            serialize() {
                return {
                    id: this.id,
                    x: this.x,
                    y: this.y,
                    w: this.width,
                    h: this.height,
                    color: this.color,
                    text: this.textContent,
                    drawing: this.drawingData
                };
            }
        }

        // --- Init ---
        const app = new App();

    </script>
</body>

</html>